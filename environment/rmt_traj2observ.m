%    This is part of RMTool - Robot Motion Toolbox, for Matlab 2010b or newer.
%
%    Copyright (C) 2016 RMTool developing team. For people, details and citing 
%    information, please see: http://webdiis.unizar.es/RMTool/index.html.
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.

%% ============================================================================
%   MOBILE ROBOT TOOLBOX
%   Graphical User Interface
%   First version released on January, 2019. 
%   Last modification January 31, 2019.
%   More information: http://webdiis.unizar.es/RMTool
% ============================================================================


function team_observ = rmt_traj2observ(Rob_places , props , Obs)
%Find possible observation set generated by team: unsynchronized movement until entering final states, moving robots SYNCHRONOUSLY enter final states
%(such strong synchronizations when entering states are needed for some LTL formulas (e.g. requiring simmultaneously entering some disjoint regions))
%   Rob_places{i} is a vector containing sequence of places through which robot i travels (in order in which they appear)
%   props - N_p atomic propositions
%   props{i} contains places (partition cells) that belong to proposition (region) i ; left-over/free space places are not included
%   Obs is the set of observations from environment (propositions on rows, padded with zeros); last row is for free space (index of proposition for free space is N_p+1)
%   the robot are assumed to move without any synchronization
%   team_observ is a vector containing indices of observations (row indices in Obs) that can be generated during unsynchronized movement of robots
%   thus, "team_observ" is a subset of 2^\Pi (set of observations)

N_r = length(Rob_places);   %number of robots
N_p = length(props); %number of atomic props.

%observations generated by each moving robot until cell before the final one; non-moving robots have one observation (synchronization is done for moving robots when entering final states)
Rob_obs = cell(1,N_r);  %Rob_obs{i} - indices of observations of robot i
Rob_obs_final = cell(1,N_r);  %last observation generated by robots
for i=1:N_r
    Rob_obs{i}=zeros(1,length(Rob_places{i})); %initialize with zeros
    for j=1:length(Rob_places{i})   %each place visited by robot i
        at_props = find( cellfun(@(x) any(x(:)==Rob_places{i}(j)) , props) ); %atomic props. that include current place of robot i
        if isempty(at_props) %no atomic prop. observed
            %at_props = N_p+1; %if want to use index of prop for free space, pad with zeros and search in Obs
            Rob_obs{i}(j) = size(Obs,1);  %index of observable for free space should be last row in Obs
        else %on else, at_props is already a sorted vector (when not empty)
            if length(at_props)<N_p %pad with zeros until number of propositions
                at_props((end+1):N_p)=0;
            end
            [~,Rob_obs{i}(j)]=ismember(at_props,Obs,'rows');    %observable index
        end
    end
    Rob_obs_final{i}=Rob_obs{i}(end);   %last observation generated by robot i
    if length(Rob_places{i})>1  %moving robot (Rob_places{i} and Rob_obs{i} have now equal lengths); remove final observation from carthesian product that is computed next (synchronize WHEN ENTERING final state)
        Rob_obs{i}(end)=[];
        Rob_obs{i} = unique(Rob_obs{i});    %keep only unique, order doesn't matter from now, because we'll take carthesian product
    end %for non-moving robots obs are stored (same for final state)
end


%observations generated by unsynchronized team movement on TRAJECTORIES, WITHOUT final state (up to entering final states)
team_obs = rmt_cartesian_product(Rob_obs{:});   %possible obs. indices from unsynchronized movement
team_obs = unique(sort(team_obs,2),'rows'); %sort each row and remove duplicate rows
team_observ = zeros(1,size(team_obs,1));   %initialize with zeros
for i=1:size(team_obs,1)    %each row is a possible observation of team
    obs_ind = setdiff(team_obs(i,:) , size(Obs,1));    %keep unique indices of observations from Obs, without free space
    if isempty(obs_ind) %only free space was observed (all robots outside regions)
        team_observ(i) = size(Obs,1);  %add index of observable for free space (should be last row in Obs)
    else
        at_props = setdiff(Obs(obs_ind,:) , 0); %observed at. props. (sorted vector, without 0)
        at_props = reshape(at_props,1,length(at_props)); %reshape as row vector
        if length(at_props)<N_p %pad with zeros until number of propositions
            at_props((end+1):N_p)=0;
        end
        [~,team_observ(i)]=ismember(at_props,Obs,'rows');    %observable index
    end
end
% team_observ = unique(team_observ);  %remove duplicates


%observation of team in FINAL state
team_obs_final = [Rob_obs_final{:}];   %obs. indices in final positions (no cathes prod., because Rob_obs_final{i} has length 1 for any robot i
team_obs_final = unique(team_obs_final);
obs_ind = setdiff(team_obs_final, size(Obs,1));    %keep unique indices of observations from Obs, without free space
if isempty(obs_ind) %only free space was observed (all robots outside regions)
    team_observ_final = size(Obs,1);  %add index of observable for free space (should be last row in Obs)
else
    at_props = setdiff(Obs(obs_ind,:) , 0); %observed at. props. (sorted vector, without 0)
    at_props = reshape(at_props,1,length(at_props)); %reshape as row vector
    if length(at_props)<N_p %pad with zeros until number of propositions
        at_props((end+1):N_p)=0;
    end
    [~,team_observ_final]=ismember(at_props,Obs,'rows');    %observable index in final positions
end

team_observ = unique([team_observ , team_observ_final]);  %add final observation (synchronized) and remove duplicates
